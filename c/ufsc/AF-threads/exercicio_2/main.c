/*Paralelize o programa dado, que realiza a soma de dois vetores. Esse programa recebe dois vetores em arquivos e mostra o resultado na saída:./program 1 a b 12 7 5 5 14 16 11 14 11 15O primeiro argumento ("1" no exemplo acima) é o número de threads, e os dois últimos argumentos são os nomes dos arquivos que contém os vetores. O programador original implementou a leitura dos argumentos e a leitura dos vetores, mas desapareceu misteriosamente antes de efetivamente usar threads. Sua implementação deve criar o número de threads indicado na variável n_threads e deve distribuir as operações c[i] = a[i] + b[i] entre essas threads. Dicas:Evite variáveis globais. Use o último argumento de pthread_create() para que cada worker thread receba um ponteiro cujo struct apontado contém as informações relevantes para aquela thread.Os arquivos a e b do exemplo acima, assim como o resultado (arquivo c) estão no esqueleto fornecido.Você não deve gerar mais threads do que elementos! Se o usuário solicitar 20 threads, e os vetores possuírem apenas 10 elementos, então apenas 10 threads deverão ser criadasÉ possível gerar vetores aleatórios com um tamanho especifico usando uma sintaxe especial:./program 1 gen:2000000 gen:2000000Cuidado para não criar vetores grandes demais e travar a sua máquina!Execute o programa com várias escolhas para o número de threads e meça o speedup. Reflita sobre os seguintes pontos:O speedup obtido está proximo do speedup ideal?O programa escala, ou seja, o speedup aumenta se aumentarmos o número de threads?*/#include <stdlib.h>#include <string.h>#include <unistd.h>#include <sys/types.h>#include <stdio.h>#include <pthread.h>#include <time.h>// Estruct que contém os dados necessários para cada threadtypedef struct {    double* a;    double* b;    double* c;    int start;    int end;} ThreadData;void* vectorSum(void* arg) {    ThreadData* data = (ThreadData*) arg;    for (int i = data->start; i < data->end; i++) {        data->c[i] = data->a[i] + data->b[i];    }    return NULL;}// Lê o conteúdo do arquivo filename e retorna um vetor E o tamanho dele// Se filename for da forma "gen:%d", gera um vetor aleatório com %d elementos//// +-------> retorno da função, ponteiro para vetor malloc()ado e preenchido// | // |         tamanho do vetor (usado <-----+// |         como 2o retorno)              |// v                                       vdouble* load_vector(const char* filename, int* out_size);// Avalia o resultado no vetor c. Assume-se que todos os ponteiros (a, b, e c)// tenham tamanho size.void avaliar(double* a, double* b, double* c, int size);int main(int argc, char* argv[]) {    // Gera um resultado diferente a cada execução do programa    // Se **para fins de teste** quiser gerar sempre o mesmo valor    // descomente o srand(0)    srand(time(NULL)); //valores diferentes    //srand(0);        //sempre mesmo valor    //Temos argumentos suficientes?    if(argc < 4) {        printf("Uso: %s n_threads a_file b_file\n"               "    n_threads    número de threads a serem usadas na computação\n"               "    *_file       caminho de arquivo ou uma expressão com a forma gen:N,\n"               "                 representando um vetor aleatório de tamanho N\n",               argv[0]);        return 1;    }      //Quantas threads?    int n_threads = atoi(argv[1]);    if (!n_threads) {        printf("Número de threads deve ser > 0\n");        return 1;    }    //Lê números de arquivos para vetores alocados com malloc    int a_size = 0, b_size = 0;    double* a = load_vector(argv[2], &a_size);    if (!a) {        //load_vector não conseguiu abrir o arquivo        printf("Erro ao ler arquivo %s\n", argv[2]);        return 1;    }    double* b = load_vector(argv[3], &b_size);    if (!b) {        printf("Erro ao ler arquivo %s\n", argv[3]);        return 1;    }        //Garante que entradas são compatíveis    if (a_size != b_size) {        printf("Vetores a e b tem tamanhos diferentes! (%d != %d)\n", a_size, b_size);        return 1;    }    //Cria vetor do resultado     double* c = malloc(a_size*sizeof(double));    if (n_threads > a_size) {      n_threads = a_size;    }    pthread_t threads[n_threads];    ThreadData thread_data[n_threads];    int chunk_size = a_size / n_threads;    int remainder = a_size % n_threads;    int start = 0;    for (int i=0; i < n_threads; i++) {      thread_data[i].a = a;      thread_data[i].b = b;      thread_data[i].c = c;      thread_data[i].start = start;      thread_data[i].end = start + chunk_size + (i < remainder ? 1 : 0);      pthread_create(&threads[i], NULL, vectorSum, &thread_data[i]);      start = thread_data[i].end;     }     for (int i=0; i < n_threads; i++) {       pthread_join(threads[i], NULL);       }    // Calcula com uma thread só. Programador original só deixou a leitura    // do argumento e fugiu pro caribe. É essa computação que você precisa     // paralelizar    //for (int i = 0; i < a_size; ++i)    //    c[i] = a[i] + b[i];    //    +---------------------------------+    // ** | IMPORTANTE: avalia o resultado! | **    //    +---------------------------------+    avaliar(a, b, c, a_size);        //Importante: libera memória    free(a);    free(b);    free(c);    return 0;}