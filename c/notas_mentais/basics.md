# A fun√ß√£o printf()
A fun√ß√£o `printf()` tem a seguinte forma geral:
`printf(string_de_controle, lista_de_argumentos)`

Teremos, na string de controle, uma descri√ß√£o de tudo que a
fun√ß√£o vai colocar na tela.
Isto √© feito usando-se os c√≥digos de controle (especificador de formato - format specifies type), veja alguns
exemplos:

| C√≥digo | Significado       |
|--------|-------------------|
| %d     | Inteiro (**D**ecimal) |
| %f     | **F**loat            |
| %c     | **C**aractere        |
| %s     | **S**tring           |
| %p     | **P**ointer addresses   |
| %x     | he**X**adecimal      |
| %%     | Coloca um % na tela |

> O especificador de tipo %x em C √© usado em fun√ß√µes como printf() e scanf() para representar n√∫meros inteiros no formato hexadecimal (base 16).

> üìå Uso no printf()
> `%x` ‚Üí Exibe o n√∫mero em hexadecimal com letras min√∫sculas (a a f).
> 
> `%X` ‚Üí Exibe o n√∫mero em hexadecimal com letras mai√∫sculas (A a F).
>
> `%02x`‚Üí Exibe o n√∫mero em formato hexadecimal, com dois d√≠gitos (completando com 0 √† esquerda, se necess√°rio).
> 
> üìå Dica: Se quiser exibir um n√∫mero hexadecimal com o prefixo 0x, use # antes do x no printf():
>```c
>printf("Hexadecimal com prefixo: %#x\n", num);
>```
>Sa√≠da:
>```c
>Hexadecimal com prefixo: 0xff
>```
>```c
>#include <stdio.h>
>
>int main() {
>    int num = 255;
>
>    printf("Decimal: %d\n", num);    // Sa√≠da: Decimal: 255
>    printf("Hexadecimal: %x\n", num); // Sa√≠da: Hexadecimal: ff
>    printf("Hexadecimal (mai√∫sculas): %X\n", num); // Sa√≠da: Hexadecimal (mai√∫sculas): FF
>    printf("Hexadecimal (dois digitos): %02x\n", num); // Sa√≠da: Hexadecimal (mai√∫sculas): FF
>    printf("Hexadecimal (prefixo 0x): %#x\n", num); // Sa√≠da: Hexadecimal (mai√∫sculas): FF
>
>    return 0;
>}
>```
> ver [arquivo](../firstSteps/formatSpecifiesType.c)




# Struct
> ver arquivo /struct/hellostruct.c
estrutura de dados imutavel com elementos de tipos diferentes que v√£o concatenando. Pode nomear essa nova estrutura dentro da linguagem, serve como um molde que quebra os valores passados como argumentos para dentro do espa√ßo de elemento.
# Tuple != Array
Tuple √© como um Struct anomino, sem nomes ou etiquetas
- Tuple: estrutura de dados (conjunto) imutavel com elementos de tipos diferentes.
- Array: estrutura de dados (conjunto) imutavel com elementos de mesmo tipo.
- Struct: estrutura de dados 

# atoi() - ASCII to Integer
> Ex: Explica√ß√£o da Linha int n_threads = atoi(argv[1]);

Esta linha de c√≥digo est√° fazendo duas opera√ß√µes importantes:

### 1. argv[1] - Acessando o argumento da linha de comando

`argv` √© o array de strings que cont√©m os argumentos passados ao programa na linha de comando
- `argv[0]` √© sempre o nome do pr√≥prio programa
- `argv[1]` √© o primeiro argumento ap√≥s o nome do programa
> Ex: No comando ./program 2 16 17, os valores seriam:
> `argv[0]` = "./program"
> `argv[1]` = "2" (n√∫mero de threads)
> `argv[2]` = "16" (primeiro valor para compute)
> `argv[3]` = "17" (segundo valor para compute)
### 2. atoi() - Convertendo string para inteiro

> atoi significa "ASCII to integer"

√â uma fun√ß√£o da biblioteca padr√£o C (stdlib.h) que converte uma string em um valor inteiro
Recebe como par√¢metro uma string (no caso, argv[1] que √© "2")
Retorna o valor inteiro correspondente (no exemplo, retornaria 2)
#### Comportamento importante do atoi():

Se a string n√£o representar um n√∫mero v√°lido, `retorna 0`

Isso √© usado na verifica√ß√£o seguinte: if (!n_threads || ...)
> Exemplos:
> 
> atoi("123") ‚Üí 123
>
> atoi("-45") ‚Üí -45
>
> atoi("0") ‚Üí 0
>
> atoi("abc") ‚Üí 0
> 
> atoi("12a34") ‚Üí 12 (converte at√© encontrar caractere n√£o num√©rico)

Por que √© necess√°rio nesta aplica√ß√£o?

O programa precisa saber quantas threads criar, e esse n√∫mero √© passado 
como primeiro argumento na linha de comando. 
Como todos os argumentos de linha de comando chegam como strings (char*),
precisamos converter para um n√∫mero inteiro que possa ser usado no 
restante do programa.

### Alternativas modernas:

Em C moderno, poderia-se usar `strtol()` que tem melhor tratamento de 
erros:

```c
char* endptr;
int n_threads = strtol(argv[1], &endptr, 10);
if (endptr == argv[1] || *endptr != '\0') {
// Tratamento de erro - convers√£o falhou
}
```
Mas `atoi()` √© suficiente para este contexto onde j√° h√° verifica√ß√£o 
posterior do valor (if (!n_threads...)).



O erro estava na fun√ß√£o mult_matrix, utilizar "#pragma omp parallel for" dentro de outro "parallel for" (paralelismo aninhado) estava causando problemas como uma condi√ß√£o de corrida no out[i*cols_right + j] += ... porque v√°rias threads estavam acessando e modificar a mesma posi√ß√£o da matriz de saida simultaneamente. para corrigir isso tiramos um dos "parallel for" e utilizamos somente um, esse aqui: #pragma omp parallel for collapse(2), utilizamos esse pois assim conseguiriamos paralelizar os dois primeiros loops (i e j) de forma combinada. Al√©m disso utilizamos uma variavel local chamda sum para receber a soma e evitar acesso simult√¢neo √† mesma posi√ß√£o da matriz de sa√≠da.

Ol√° estagi√°rio,

Identificou-se alguns problemas no seu c√≥digo de multiplica√ß√£o de matrizes que explicam os resultados incorretos e o desempenho abaixo do esperado:

1. Race Condition (Condi√ß√£o de Corrida)

O principal erro est√° na paraleliza√ß√£o do loop mais interno da multiplica√ß√£o:

Problema: V√°rias threads est√£o tentando atualizar out[i*cols_right+j] ao mesmo tempo, causando uma condi√ß√£o de corrida. Quando m√∫ltiplas threads acessam e modificam a mesma vari√°vel simultaneamente sem sincroniza√ß√£o, o resultado final fica incorreto.

Solu√ß√£o: Movemos a paraleliza√ß√£o apenas para o loop externo e usamos uma vari√°vel local sum para acumular os resultados antes de escrever na matriz de sa√≠da.

2. Paraleliza√ß√£o Excessiva

Voc√™ usou tr√™s n√≠veis de paraleliza√ß√£o:

No loop externo (i)
No loop do meio (j)
No loop interno (k)
Problema: Isso cria um overhead enorme de gerenciamento de threads sem benef√≠cio real, pois:

- Cada thread adicional tem custo de cria√ß√£o
- O trabalho por thread fica muito pequeno
- O sistema gasta mais tempo gerenciando threads do que computando
Solu√ß√£o: Paralelizamos apenas o loop mais externo (i), que fornece trabalho suficiente para cada thread e minimiza o overhead.

3. Agendamento Ineficiente

Voc√™ usou:

- schedule(guided) na inicializa√ß√£o
- schedule(dynamic,1) na multiplica√ß√£o
Problema: Esses esquemas de agendamento introduzem overhead desnecess√°rio para matrizes, onde o trabalho √© uniformemente distribu√≠do.

Solu√ß√£o: Usamos schedule(static), que:

- Divide o trabalho igualmente entre as threads no in√≠cio
- Tem quase zero overhead durante a execu√ß√£o
- √â ideal para cargas de trabalho regulares como matrizes